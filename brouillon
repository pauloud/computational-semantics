data ModalContext fn var pred world elem m = ModalContext {
    actualWorld :: m world,
    accessibility :: world -> m [world],
    domain :: world -> m [elem],
    fnV :: fn -> [elem] -> m (Maybe elem),
    varV :: var -> ModalT fn var pred world elem m (Maybe elem),
    predV :: pred -> [elem] -> m Bool



}


type ModalT fn var pred world elem m =
    ReaderT (ModalContext fn var pred world elem m) m

termValue :: Monad m => Term fn var pred -> ModalT fn var pred world elem m (Maybe elem)
termValue = \case
    Var x -> do
        context <- ask
        varV context x
    Struct f terms -> do
        values <- mapM termValue terms
        if any isNothing values then return Nothing else do
            context <- ask
            lift $ fnV context f (map fromJust values)
    The x formula -> return $ error "definite description not yet implemented"


changeWorld :: Monad m =>  m world
    -> ModalT fn var pred world elem m a
    -> ModalT fn var pred world elem m a
changeWorld w = local (\context -> context{actualWorld = w})

formulaValue :: Monad m => Formula fn var pred -> ModalT fn var pred world elem m Bool
formulaValue = \case
    Atom p xs -> do
        context <- ask
        values <- mapM (varV context) xs
        if any isNothing values then return False else do
            lift $ predV context p (map fromJust values)
    Box f -> do
        context <- ask
        possibleWorlds <-  actualWorld context >>= accessibility context 
        return undefined


askContext = asks fst
askSubstituion:: Monad m => ModalT fn var pred world elem m (Substituion fn var pred world elem m)
askSubstituion = asks snd 
data ModalContextT world elem m = ModalContext {
  actualWorld :: forall a. (world -> ModalT world elem m a) -> ModalT world elem m a,
  possibleWorld :: forall a. (world -> ModalT world elem m a) -> ModalT world elem m [a],
}
type ModalT world elem m = ReaderT (ModalContextT world elem m) m 

module ModalModel where

data Player = X | O deriving(Eq,Show)
grid1 = 
    [[[O],[],[]],
     [[],[X],[]],
     [[],[X],[]]]
grid11 = 
    [[[O],[],[]],
     [[O],[X],[]],
     [[],[X],[]]]
grid111 = 
     [[[O],[X],[]],
     [[O],[X],[]],
     [[],[X],[]]]

grid12 = 
    [[[O],[O],[]],
     [[],[X],[]],
     [[],[X],[]]]
grid121 =
    [[[O],[O],[X]],
     [[],[X],[]],
     [[],[X],[]]]

nextPlayer g 
    |g == grid1 || g == grid121 = Just O 
    |g == grid11 || g==grid12 = Just X 
    |g == grid111 = Nothing 
    |otherwise = error $ "nextPlayer function not implemented for grid " ++ show g
winner g 
    |g == grid111 = Just X
    |elem g [grid1,grid11,grid12,grid121] = Nothing 
    |otherwise = error $ "winner function not implemented for grid " ++ show g


data Elem = Player Player | Pos Int Int deriving (Show,Eq)  









